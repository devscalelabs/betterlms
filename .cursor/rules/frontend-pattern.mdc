---
globs: *.tsx
alwaysApply: false
---
# Component-Hooks Pattern

This document explains the component-hooks pattern used in the BetterLMS platform frontend application.

## Overview

The application follows a **component-hooks pattern** where business logic is separated from UI components using custom React hooks. This creates a clean separation between presentation and logic.

## Pattern Structure

```
features/
├── feature-name/
│   ├── components/       # UI components (presentation)
│   ├── hooks/           # Custom hooks (business logic)
│   ├── types/           # TypeScript types
│   └── utils/           # Utility functions (optional)
```

## How It Works

### 1. Components Handle UI Only

Components focus purely on rendering and user interactions:

```tsx
// features/posts/components/post-form.tsx
export const PostForm = ({ parentId, replyToPost, onSuccess }: PostFormProps) => {
  const {
    formData,
    setFormData,
    selectedImages,
    handleFileChange,
    removeImage,
    createPost,
    isCreatingPost,
  } = useCreatePost({
    ...(parentId && { parentId }),
    ...(onSuccess && { onSuccess }),
  });

  const handleSubmit = (event: React.FormEvent) => {
    event.preventDefault();
    if (formData.content.trim()) {
      createPost();
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <textarea
        value={formData.content}
        onChange={(e) => setFormData({ ...formData, content: e.target.value })}
      />
      <Button type="submit" disabled={isCreatingPost}>
        {isCreatingPost ? "Posting..." : "Post"}
      </Button>
    </form>
  );
};
```

### 2. Hooks Handle Business Logic

Custom hooks contain all the business logic, state management, and API calls:

```tsx
// features/posts/hooks/use-create-post.ts
export const useCreatePost = ({ parentId, onSuccess }: UseCreatePostOptions = {}) => {
  const [formData, setFormData] = useState<CreatePostRequest>({
    content: "",
    images: [],
  });

  const queryClient = useQueryClient();

  const { mutate: createPost, isPending: isCreatingPost } = useMutation({
    mutationFn: async () => {
      const formDataToSend = new FormData();
      formDataToSend.append("content", formData.content);
      if (parentId) {
        formDataToSend.append("parentId", parentId);
      }

      const response = await api
        .post<CreatePostResponse>("api/v1/posts/", {
          body: formDataToSend,
        })
        .json();
      return response;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["posts"] });
      setFormData({ content: "", images: [] });
      onSuccess?.();
    },
    onError: (error) => {
      console.error("Failed to create post:", error);
    },
  });

  return {
    formData,
    setFormData,
    selectedImages: formData.images || [],
    handleFileChange,
    removeImage,
    createPost,
    isCreatingPost,
  };
};
```

## Hook Types

### 1. Query Hooks (Data Fetching)

For reading data from the server:

```tsx
// features/posts/hooks/use-posts.ts
export const usePosts = (filters?: UsePostsFilters) => {
  const { data: postsData, isLoading: isLoadingPosts } = useQuery({
    queryKey: ["posts", filters],
    queryFn: () => {
      const params = new URLSearchParams();
      if (filters?.parentId) params.append("parentId", filters.parentId);
      if (filters?.username) params.append("username", filters.username);

      const url = params.toString()
        ? `api/v1/posts/?${params.toString()}`
        : "api/v1/posts/";

      return api.get<PostsResponse>(url).json();
    },
  });

  return {
    posts: postsData?.posts || [],
    isLoadingPosts,
  };
};
```

### 2. Mutation Hooks (Data Updates)

For creating, updating, or deleting data:

```tsx
// features/posts/hooks/use-delete-post.ts
export const useDeletePost = () => {
  const queryClient = useQueryClient();

  const { mutate: deletePost, isPending: isDeletingPost } = useMutation({
    mutationFn: async (postId: string) => {
      const response = await api
        .delete<DeletePostResponse>(`api/v1/posts/${postId}/`)
        .json();
      return response;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["posts"] });
    },
    onError: (error) => {
      console.error("Failed to delete post:", error);
    },
  });

  return {
    deletePost,
    isDeletingPost,
  };
};
```

### 3. State Management Hooks

For managing local component state and complex interactions:

```tsx
// features/posts/hooks/use-posts-filter.ts
export const usePostsFilter = () => {
  const [filters, setFilters] = useState<UsePostsFilters>({});

  const updateFilters = (newFilters: Partial<UsePostsFilters>) => {
    setFilters((prev) => ({ ...prev, ...newFilters }));
  };

  const clearFilters = () => {
    setFilters({});
  };

  return {
    filters,
    updateFilters,
    clearFilters,
  };
};
```

## Usage Pattern

```tsx
// 1. Import the hook
import { usePosts } from "../hooks/use-posts";

// 2. Use the hook in component
export const PostsList = () => {
  const { posts, isLoadingPosts } = usePosts({ username: "john" });

  // 3. Use returned values in JSX
  if (isLoadingPosts) return <div>Loading...</div>;

  return (
    <div>
      {posts.map((post) => (
        <PostCard key={post.id} post={post} />
      ))}
    </div>
  );
};
```

## File Organization

```
features/posts/
├── components/
│   ├── post-card.tsx          # Individual post display
│   ├── post-form.tsx          # Post creation form
│   └── posts-list.tsx         # List of posts
├── hooks/
│   ├── use-posts.ts           # Fetch posts
│   ├── use-create-post.ts     # Create post logic
│   ├── use-delete-post.ts     # Delete post logic
│   └── use-posts-filter.ts    # Filter posts
├── types/
│   └── index.ts               # Type definitions
└── utils/
    └── extract-mentions.ts    # Utility functions
```

## Best Practices

1. **Hook Naming**: Use `use` prefix followed by descriptive name (e.g., `useCreatePost`)
2. **Return Objects**: Always return an object from hooks for consistent destructuring
3. **Type Safety**: Define clear TypeScript interfaces for all parameters and return values
4. **Error Handling**: Include proper error handling in all hooks
5. **Cache Invalidation**: Invalidate relevant queries after mutations
6. **Side Effects**: Handle side effects like form resets in onSuccess callbacks
7. NEVER CREATE BARREL FILE FOR apps/*

This pattern ensures clean, maintainable, and testable code by keeping UI and business logic separate.
